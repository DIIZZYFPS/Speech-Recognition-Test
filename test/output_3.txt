 Hello. In this video, we'll talk about Maven, the most popular build tool for Java projects. In software, build usually means the process of taking a project, including its source code, metadata files, resources, and libraries, and package them into a format or formats for execution, distribution, and or deployment. For many people, when they see the build button in an IDE, they just think of it as compiling the source code. But for a non-trivial project, build often involves a lot more than just compilation. For example, before compilation, you may have a preprocessing step that generates code from annotations and other metadata. And after compilation, you may have a post-processing step linking different object files together. Things like testing, packaging, even distribution and deployment can all be part of a build process. So what's wrong with just using an IDE, which seems to build projects just fine? Well, two things. First, you may not have the same IDE everywhere. For example, other developers on the same project team may prefer a different IDE. And on a server, you may only have command line tools. A build tool can have a command line version and be integrated with different IDUs, so it can provide a consistent build process across different platforms and IDEs. Another advantage is that a build tool can usually be programmed to provide additional functions. So if your IDE doesn't do something you want, you can program a build tool to do it. Today, we focus on the build tool called Maven, which has been the most widely used Java build tool for many years. Let's take a quick look at a study conducted in 2021. It's about various tools used by Java developers. And here is a part about build tools. As we can see here, Maven is used by 76% of Java developers and compare that to the So in other words, when we use Eclipse, we do not need to install Maven separately. Maven also influences the design of newer Java build tools like Gradle, for example. So things we learned today, like project coordinates, default directory structure, dependency dependency management, and so on apply to other Java build tools as well. OK, so with some introduction out of the way, let's see how Maven works with a simple example. In Eclipse, we can create a Maven project. We can do it in several different ways. We can go from File, New, Maven Project, or we can click this New button and select Maven Project from here. And on this screen we will check this option. It says create a simple project. Parentheses skip archetype selection. Archetype is something that we'll talk about later. So for our first example, we will skip Archetype and just create a simple project. Now on the second screen, we are supposed to enter a few things for the project, in particular, Group ID, ArtifactID. So what are those things? Well, GroupID and ArtifactID and version together with packaging and optional element called classifier, these five things are collectively known as mainline coordinates. Mainline coordinates are used to uniquely identify a project, kind of like we use coordinates to locate a point in space. Group ID is a label representing the company, organization, team, and so on this project belongs to. And it usually uses the reverse URL naming convention. For example, suppose we develop a project for the computer science department. We can use a group id that looks like this edu csulacs and for your project developed in this class you can give it a group id like edu-csula-3220-stu-31 or whatever your student account is. And then the artifact ID is basically project name, which can be anything. For example, you can have a project for lab 1, or you can have a project for homework 2, and so on. You can see that by combining group ID with the artifact ID, we can make sure that our homework 2, for example, will not be confused with the homework 2 project by a different student in the class. In addition to group ID and artifact ID, we can further specify version, packaging format, and optionally some additional information about the project. And typically it's something like CPU architecture, for example, the POSA project is for x86 CPU architecture or ARM CPU architecture and so on. The last coordinate is optional, but you do see some projects having this classifier typically used for specifying different CPU architectures and so on. The combination of all this information ensures that we can uniquely identify a product or a piece of software. Now, that all sounds very complicated. Can we just use project name without all the other stuff like group ID? Well, you can check out this article and see what may happen when two projects choose the same name and neither wants to give it up. OK, so back to our example. Now that we know what group ID, artifact ID, and so on means, we can give it a group ID. And I'll say EDU CSULA, CS3220, SDU31. And then artifact ID, alkoid-layman-test, nbn-test, and we can leave all the rest empty or as default and click finish. So now we have a layven project and this project is empty except for a Maven build file. This one called pom.xml which we'll talk about in a moment. But before we do that, let's quickly create a class and I'm going to create a class called HelloWorld, of course. And this class will be inside the package. And the default package name is mainTest. So we'll keep that. And I want main method inside this class and inside this class let's just output something we'll say system dot out dot print line and if we run this it's a Java application. So we write it as a Java application, and it prints out, hello Maven, which is what it says here. So that's something we already know. Now, before we talk more about Maven, I'd like to refresh our memory about a couple of things. First is Java package, which is this part. So remember, in Java, we can use package to group classes together. And then this serves two purposes. First, it avoids class name conflicts. For example, you can have two account classes in your project. Maybe, for example, one account class under the user package and this account represents a user with username and password and so on. And maybe you have another account which represents bank accounts. So you can have another account class maybe under the bank package. This way, we won't have class name conflicts. They are in different packages. A second reason to have packages is so that we have another level of so-called encapsulation, and that's in addition to public, private, class, and subclass, and so on. Also remember that there could be different levels of packages. For example, let's say we create another class. And this time, we'll put this class under the package maventest.user. And then maybe I'll just call this class account. And this one will have a username, a password, and so on. So what's inside the class is not important. What's important is I want to show another package and this time we have another package which is inside the or under the mvm test package. And first of all, notice that it's again, typically using the reverse URL naming convention. So the package names looks kind of like URLs. And secondly, the package structure must match the directory structure of disk. And in Eclipse, we can see that here, under the Java folder, we have MainlandTest and inside MainlandTest we have the hello world class which is this one and underneath we have another folder user and this directory structure Mainven test, containing user corresponds to the package structure with maven test and then maven test.user. And inside this package, we have account. So package structure matches the folder structure, and that's a requirement of Java. Now, these are all things that we already studied in previous Java classes, but I just want to brush up on these things because oftentimes in this class, some students forget about package and for web applications, we do need to use packages unlike some desktop programs where we can skip package or use the so-called default package. Anyway, this part, the part that shows hello world.java here, but also hello world.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.java.j world.java here, but also hello world.java here, kind of brings up to the second refresher, which is about Eclipse project display. So notice that for a Java project Eclipse would display the Java resources separately this part and then at the same time also displays the files and folders. So a Java class like hello maailon in the screenshot or HelloWorld here in our actual example, you can see that it actually appears twice. This can be a little confusing, but just know that these two Java files are actually the same file appearing in two different colon code views. So when we work on Java project, usually we just work on the Java resources part. In other words, we really just work on this part and we don't really need to worry about the folder and file structure. But occasionally, if you expand this, you'll see the same file. Don't get confused. It's actually the same thing displayed twice and there are different views. OK, now back to Maven. And now we need to look at this file, pom.xml, which is the important stuff. So this file, pom.xml, is known as a build file of Maven. Each build tool needs a so-called build file, and a build file basically describes how the project should be built. In Maven, the build file is with the name pom.xml. And pom stands for project object model. It's a fancy name, but it's basically a set of XML tags used to describe a project. For example, we can see here that we have a group ID tag and it's used for group ID and we have artifact ID tag for artifact ID and so on. So this set of XML tags could also evolve over time, meaning that new tags may be added, old ones may be deprecated, and so on. Hence the model version here, which is 4.0.0. And it has been 4.0.0 for many years, meaning that we probably won't see any new tags for project description. And this set of tags are pretty sufficient. Now, this pom.xml file is called a complete description of a project, meaning that if we have this file for a project, we know exactly how the project is structured and how it should be built. However, when we look at this pom file, it seems like there's really nothing here other than the project coordinates, right? So how are we supposed to build this project? Well, we use defaults, or as people say, convention over configuration. In Eclipse, we can click on the Effective Palm tab. It's down here, right next to palm.xml. And in this tab, we can see the actual com file used by Maven with all the default settings explicitly spelled out here. And we can see that there are lots of default settings. We don't really need to know most of these defaults. But one thing we must really understand is the default directory structure, as virtually all Malin projects use the same directory structure. And these are the folders in this directory structure that we'll see most often. And here we can also see the folders for this project. In Maven, there are usually two folders, the SRC folder or the source folder and the target folder. SRC is for source files and the target is for generated files like class files. Inside SRC, there are main, and there's the test folder. Main is for application code, and the test is for test-related code. Inside main, we have the Java folder, which is for Java source code. And then we have the resources folder, which are for files that should be placed under class pass, your configuration files. And if it's a web application, then we would also have a web ATP folder in the source-lane folder. And this one would be for files like HTML pages, CSS style sheets, and so on. Note that we don't have to have all the default folders in all projects. For example, since this project is not a web project, it doesn't have the WebAPB folder. And if we don't want to write any text code, we can simply remove the text folder. and that's perfectly fine. You could configure Maiman to use a different directory structure, but there's really no good reason to do that. By sticking to the default directory structure, it's easier for other people to understand your projects, and it's easy for you to understand other people's projects. So now we know how a Maven project is structured, it still doesn't answer the question how we can build it. In particular, what happens if we do something like this? In Eclipse, we select the project and then right-click on the project and then select Run as and then Maven build, Maven clean, Maven install, Maven test, and so on. What happens if we choose, for example, main install, main test? Well, the answer is simple, but it needs quite a bit of explanation. So what happens when we run Maven, something like Maven install? And the first thing we need to understand is that things like install, test, verify, and so on, those are Maven build cycle phases. And secondly, when we say something like Maven install phase or Maven test phase, what Maven does is it will go through each phase of the build lifecycle up to the specified phase and run the operations associated with each phase. So what exactly are these things? What exactly are build lifecycle, phases, operations, and all that? Well, let's start with build lifecycle. Build lifecycle is a process for building and distributing a project. And the build lifecycle consists of a number of steps called phases. What's kind of unique about Maiden is that it defines a few standard build life cycles, basically saying that regardless of what project you have, your project can use standard build life cycles main and defines all the generated files and folders. The site lifecycle is for generating documentation. These two are not important. The important one is the default life cycle, which, according to Maven, has all the steps needed to build any project. It starts with a validate phase, and then initialize, then generate resources, then process resources, and so on and so forth, all the way to the deploy phase. These are certainly lots of steps or phases in the Bbot build lifecycle. What if our project is not this complex? Well, that's perfectly fine. The default build lifecycle specifies all the possible phases, but not all projects need to use all of them. For a project, most phases can be empty, meaning that there are no operations associated with them. Here's an example of what happens if we do Maven compile. It basically tells Maven to go through each build lifecycle phase up to the compile phase. So go from here up to here. Note that by default, there's actually no operation associated with phases like validate, initialize, and so on. The first operation we will encounter is actually in the process resources phase. And this operation simply copies the resource files to the class bus. And then in the next phase, we have the compile operation that compiles a source code. So this is basically how Maiden build works. It simply goes through each phase up to the one we specify, and then run the operations associated with each phase. And in most cases, there's no operations associated with a phase. But if there is, it will just when mainline reaches that phase. So those operations are provided by mainline plugins, and we can see the list of official Maven plugins here. So here, for example, we have the clean plugin, the compiler plugin, deploy plugin, and so on and so forth. Several of these plugins are included in a build by default. For example, the compiler plugin is included by default. Each plugin provides one or more operations, and those operations are called goals. For example, this compiler bugging provides two operations, aka two goals. And one is a compile goal, and the other one is a test compile goal. Each goal is associated or bound to a lifecycle phase, for example, compile is bound to the compile phase, compile phase, and test compiler is bound to the test compiler phase. So as we mentioned earlier, when we do a build, these goals will be run when we reach that phase where the goal is associated to or bound to. And of course, these goals can be customized with additional configuration. For example, we can specify what Java version to use to compile a project. As we just saw earlier, Eclipse IDE provides a few mainline views like main install, main test, and so on. What if we want to run other mainline builds? For example, what if I want to do a mainline compile? Now this is how we can do it. We select main build dot dot dot and here we can specify the face, the compile face in the field called goals and then we can give this build a name and we can call it mvintestcompile, for example. And save it, and then we can run it. And this will run mvintestcompile build on this project. And it will compile two source files and build success. Later on, if we want to rerun this build, we can go here. As you can see, it saves MVM test compile build here. So this is how we can run additional mainline build in Echarybs.. Now let's do another example. And I want to use this example to show two more mainland features, Archetype and Dependency Management. Let's create another main project. And this time we'll leave this option, create a simple project unchecked. In other words, this time we are going to create a project from an archetype. So what are archetypes? Maybe archetypes are basically project templates, kind of like the ones provided by IDEs. It's usually more convenient to create a project from a template than creating it from scratch. The good thing about Maven archetype is that anyone can create archetypes. So if your IDE doesn't provide a certain project template, you can create one for yourself. The downside is that because anyone can create archetypes, there are lots of low quality or no longer maintained archetypes out there. And that's what happens if you are on this screen and you select all catalogs, you'll see all the archetypes and it's impossible to find something that you want here. It's just too much, plus most of those archetypes are not that good to be gamers. Now, Mainland does provide some official archetypes like Quickstart and WebAQT, but those archetypes are very updated, so not very good good and because of these reasons I created my own archetype for this class and it's GitHub here. So the process of installing this archetype is part of the process to setting up the development environment. I'm not going to show it here and if you want you can check out the video showing the process of second-after development environment. Anyway I already installed this archetype on my computer and we can now use it to create web projects. So instead of selecting all catalogs, we will select default local. And this archetype is right here. And it's called simple serverlet archetype. And we can use it to create a web application. Like before, we'll give it a group ID and I'm going to still use the CSULA3220, student31 and artifact ID are quite named, test2. Now for web applications, the Java classes must be in a package. They cannot be in the default package or aka no package. Now by default, Maywe assumes that the top level package is the group ID plus the artifact ID and I really don't like my top level package to be that long. So instead, I'm just going to simply use CS3220 as a top level package. And also I'm going to uncheck run archetype generation interactively because if we leave this unchecked, they will ask us to enter a package again or confirm package again. It's kind of unnecessary and annoying. So uncheck this, give it a top-level package name, the rest we already know. And then we create the project. So now we have this MVM test tool project. And in this project, the archetype automatically creates a servlet for us called HelloServlet. It also creates HTML file index.html. We'll talk more more about service and web applications in a separate lecture. Here, I'm not going to actually run this. We saw how to create a web application using Archetype, and I want to show one more Maven feature which is dependency management. A dependency of a project is basically a library the project depends on. In Maven, adding a dependency to a project is as simple as adding the core base of the library to prom.xml file. Maven automatically downloads a library from an online repository and stores it locally for future use. For example, suppose in this project, suppose we want to do unit test using the library JUnit. We can add it to the project like this. So we go to palm.xml. OK, so it already has a dependency here. And let's add one more. We'll say dependency and we'll say JUnit and it will show a bunch of JUnit for us to choose and we want this one. I think the artifact ID is called jUnit, not jUnit.bar. Or maybe dependency jUnit. dependency missing artifact of jenjonit so maybe it's not called jenjonit let's try it here. Dependencies? Dependency. Oops, not this one for some reason this one doesn't show up In here, But let's replace it here. OK. All right. Not completely smoothly, but still better than manually download the library and add it to the project. So basically, as we can see here, if we want to add a library to the project, we just need to know the call names of the library. And then we add that to pom.xml and Maven will automatically go to online repository, grab the library, download it, and add it to the project. Much better than we having to do it manually ourselves. It's really convenient. Weyman actually does more than just grab the dependencies we specify. It also automatically has dependencies of a dependency, also known as transitive dependencies. And so in other words, if a library that we use depends on other libraries, those other libraries will be automatically included. Once again, it's very convenient. And sometimes we may have a situation where one library needs a certain version of another library, but a different version of the same library is needed by different dependencies. This is known as dependency conflicts. Maiden can resolve dependency conflicts either automatically based on certain rules or manually if they add some additional configuration. So one or more, it's very convenient to use Maven to handle libraries used by our projects. So to summarize, Maven is a very important and very useful tool in Java development. We don't have to be a Maven expert to use it, but we do need to understand a few basic things, in particular the coordinates, the group ID, the artifact ID stuff, the default directory structure, especially these ones. And what are the build life cycles, build life cycle phases, and what it means when we say build install, maybe install or maven compile, and what is a maven archetype and how to use it, and how to add dependencies to a project. Those are basic things that we have to know as we'll use mail and quite often in the rest of the class. Okay, so this is it. Thank you and see you in the next video.