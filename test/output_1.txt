 Hello, in this video we'll talk about Maven, the most popular build-through for Java projects. In software, build-yoly means the process of taking a project, including its source code, metadata files, resources, and libraries, and package them into a format or formats for execution distribution and or deployment. For many people, when they see the build button in the IDE, they just think of it as comparing the source code. But for a non-trivial project, build often involves a lot more than just compilation. For example, before compilation, you may have a non-trivial project, build up and you'll also look more than just compilation. For example, before compilation, you'll may have a pre-processing step that generates code from annotations and other metadata. And after compilation, you'll may have a post-processing step linking different object files together. things like testing, packaging, even distribution and deployment can all be part of a build process. So what's wrong with just using an IDE? Which seems to build projects just fine. Well, two things. First, you may not have the same IDE area, for example. As a developer on the same project team may prefer a different IDE. And, uh, server, you may only have command line tools. A build tool can have a command line version and be integrated with different IDE use. So it can provide a consistent build process across different platforms and IDs. Another advantage is that a build tool can usually be programmed to provide additional functions. So if your IDE doesn't do something you want, you can program a build tool to do it. Today we focus on the build to create which has been the most widely used Java build for many years. Let's take a quick look at a study conducted in 2021. It's about various tools used by Java developers. And here is a part about build tools. As we can see here, Mainment is used by 76% of Java developers and compared that to the second place grade of which which had exactly half of the market share. So, maintenance of its popularity, it's integrated in all the popular Java IDs like Eclipse. So in other words, when we use Eclipse, we do that, need to install it separately. Make an also influence the design of newer Java build tools like Grid of for example. So, since we learned to build like project coordinates, people direct structure, dependency dependency management and so on apply to other channel built with as well. Okay, so let's some introduction out of the way. Let's see how layman works with a simple example. In Eclipse we can create a layman project. We can do it in several different ways. We can go from file, new layman project, or we can click this new button and the select layman project from here. And this screen screen we will check this option. This says create a simple project. Princesses skip archetype selection. archetype is something that we'll talk about later. So for our first example, we will skip archetype and just create a simple project. Now on the second screen, we are supposed to enter a few things for the project, in particular, group ID, artifact ID. So what are those things? Well group ID and artifact ID and version together with packaging and optional and called classifier, these five things are clacky being known as main and call updates. and called classifier. These five things are correctly known as main and colonnades. Main and colonnades are used to uniquely identify a project. Kind of like we use colonnades to locate a point in space. Group ID is a label representing the company, the, team and so on. This product belongs to, and it only uses the reverse URL label translation. For example, suppose we develop a project for the computer science department, we can use a group ID that looks like this in the new CSULACS. And for your project developing this class, you can give it a group ID, like eatingULA, say 32, 20, STU 31, or whatever you are, still a county is. And then the artifact ID is based to a project name, which can be anything, for example, you can have a project for lab one or a project for homework two and so on. You can see that by combining group ID with the artifact ID, we can make sure that our homework two, for example, will not be confused with the homework tool product by a different student in their class. In addition to group ID and architecture ID, we can further specify version, packaging format, and optionally some additional information about the project. And typically it's something like CPU architecture, for example, the those are project events for x86, CPA, architecture, or Happy particular patron and so on. The last coordinate is optional, but you do see some projects having this classifier typically used for specifying different secure textures and so on. The combination of all this information ensure that we can uniquely identify a product or a piece of software. Now, that all sounds very complicated. Can we just use project name without all the other stuff like group ID? Well, you can check out this article and see what may happen when two projects towards the same name and the laser must to give it up Okay, so back to our example now that we know what group ID artifact ID and so on means, we can give it a group ID and I'll say it uses your LA is 3220, as the user do one. then RT- IPD I'll call it Maven test and be in test then we can leave all the rest empty or SP4 and click finish. So now we have a name and project and this project is M-H-E-T-E want a lame method inside this class and inside this class let's just output something will say it's just the output of the green line and a show name and if we run this it's such our application. So we write as a Java application and it prints out hello main, which is what it says here. So something we already know. Now before we talk more about mainly I like to refresh our memory about a couple of things. First is Java package, which is this part. So remember in Java we can use package to group classes together and then this serves two purposes. First it avoids class name conflicts. For example you can have two account classes in your project. Maybe, for example, one account class in there, the user package and this account represents a user with user name, password and so on. And maybe you have another account which represents bank accounts. So you can have another account class, maybe, and there is a bank package. This way, we won't have class name conflicts. They are different packages. But second reason to have packages is so that we have another level of so-called encapsulation. And that's in addition to public, private, class, and subclass, and so on. Also remember that there could be different levels of packages, for example, let's say we create another, let's say we create another class. and this time we'll put this class in there. The package may then test dot user and maybe I'll just call this class account and this line will I'll have a user name, a password and so on. So what's inside the class is not important. important is I want to show another package and this time we have another package which is inside or under the main package, a main test, and a main task package. First of all, notice that it's, again, typically, using the reverse URL, the information, or the package names, looks kind of like URLs. And secondly, the package structure must match the directory structure of disk and it clips. We can see that here under the Java folder we have main and test, and underneath the inside main and test we have the Hello World class, which is this one, and underneath we have another folder user, and this directory structure main and test, continue user, and corresponds to the package structure, this may then test and that may then test out user. Inside this package we have account. Package structure matches the folder structure, and that's a requirement of Java. Now these are all things that we already studied in previous Java classes, but I just want to brush up these things because of the times in this class, some students forget about package and for web applications, we do two use packages and XM desktop programs where we can skip package or use it with some called different package. Anyway, this part, the part that shows hello World.jalah here, but also Hello World.jalah here, cannot bring up to the second refresher, which is about a project display. So notice that for a JALA project a display, the Java resources separately, this part, and then at the same time also displays the files and folders. So a Java class like hello, main menu in the screenshot or hello word here. Now actual example, you can see that it actually appears twice. This can be a little confusing, but just know that this two Java files are actually the same file appearing in two different colanko views. So when we work on Java project, usually we just work out the Java resources part. In other words, we usually just work out this part and we don't usually will worry about the folder and file structure. But occasionally if you expand this you will see the same file, don't get confused, it's actually the same thing, displayed twice and there are different views. Okay, now back to maybe and now we need to look at this file, POM.xml, which is the important stuff. So this file, from.xml, is known as the build file of mail. Each build tool is a so-called build file, and a build file basically describes how the project should be built. In Mayland, the build file is with the name POM.xml, and POM stands for Project Object Model. It's a fancy name, but it's basically a set of XML tags used to describe a project. For example, we can see here that we have a group ID tag and the issues for group ID and we have a party tag ID tag for artifact ID and so on. So this set of XML tags could also evolve over time, meaning that new cats may be added or once may be deprecated and so on, hence the model version here, which is 4.0.0, it has been 4.0 point off from any air smooth that way. Probably want to see any air smooth. and it has been 4.0.0 from any years moving that way. Probably want to see any new tags for our project description. This set of tags are pretty sufficient. Now this hard got XML file is called a complete description of a project, meaning that if we have this file for a project, we know exactly how the project is structured and how it should be built. However, when we look at this pop file, it seems like there's really nothing here other than the project of this, right? So how are we supposed to build this project? Well, we use defaults or as people say, can mention over configuration. In Eclipse, we can click on the effective prompt tab. It's done here right next to command.xml. And in this tab, we can see the actual com file used by maiden with all the default settings explicitly spelled out there. And we can see that there are laws of people settings. we don't really need to know most of these people, but one thing we must really understand is the people directly structure as virtually all male and project used the same directly structure and these are the folders in this directory structure that we'll see most often. And here we can also see the folders for this project. You may even that you're the two folders, the SRC folder, the source folder and the private folder. SRC is for source files and the target is for generated files like class files inside Inside SRC, there are many. And there's a test folder. Main is for application code. And the test is for test-related code. Inside Main, we have the Java border, which is for Java source code. Then we have the resources folder, which are for files that should be placed in their class pass, your configuration files. And if it's a web location, then we would also have a web HTTP folder in their source length folder. And this one would be for files like HTML pages, CSS, HTML, HTML, functions and so on. Not that we don't have to have all the default folders in all projects, for example, things. options and so on. Note that we don't have to have all the default folders in all projects. For example, since this project is not a web project, it doesn't have the web-acubable folder. And if we don't find tool right in the test code, we can simply remove the text folder. that's perfectly bad. You'll call the configure mainment to use at different directory structure, but there's really no good reason to do that. By sticking to the people of directory structure is easier for other people to understand your projects and it's easy for you to understand other people's projects. So now we know how a maven project is structured. It still doesn't answer the question how we can build it. In particular, what happens if we do something like this when we click the clips, we select the project and then you are going to create a project and then select one as and then name and build name and name and name and name. restore, make a test and so on. What happens if we choose, for example, name and store, name and test? Well, the answer is simple, but it means quite a bit of explanation. So what happens when we've made something like a new store and it's first thing we need to understand it that. It seems like things like... things like in store, test, verify, and say something like mainland on store phase, or mainland test phase. What mainland does is it goes to each phase of the build life cycle up to the specific face and when the operations associated with each face. So what exactly are these things? What exactly are build life cycle, faces, operations and all that? Well let's start with build life cycle. Build life cycle is a process for building a distributed product. And build life cycle consists of a number of steps called phases. What's kind of unique about the way that it defines a few standard build life cycles, cycles,, basically saying that regardless of what project you have, your project can use these build life cycles. So here are the three standard build lifestitels main and removing all the generated files and folders. The side life cycle is for generating dark ventilation, this one now is important. The important one is the default life cycle, which according to Maven has all the steps needed to build any project. It starts with a validate phase and then initialize, then generate resources, then process resources, and so on and so forth. Also, we need to let people go ahead and face. These are certainly lots of steps, or faces will be built by a cycle. What if our project is not this context? Well, that's perfectly fine. The build life cycle specify all the possible phases, but not all products need to use our content. For our project, most phases can be empty, meaning that there are no operations associated with them. Here's an example of what happens if we do main and compile. It basically tells main and we go through each build-life cycle place up to the compile phase. So go from here up to here. Note that by default, there's actually no operation associated with faces like validate, the initial eyes and so on. The first operation we will encounter is actually the process resources face and this operation simply copies the resource files to the class pass. And then the next face we have the compile operation that compiles a source code. So this is basically how maybe the field works. It simply goes through each phase to the one we specify. And then, when the operations are associated with each phase, and in most cases, there's no operations associated with our face, but there is a paragraph one main and which is that face. So those operations are provided by main and plugins and we can see the list of official main and plugins here. So here for example we have the clean plugin, the compiler plugin, the point plugin and so on and so forth. Several of this puddings are included in a view by default, for example, it's a compiler parking, it's a blueprint. By default, each parking provides one or more operations and those operations are called goals. For example, this compiler, by being provides two operations, 888, two goals, and one is the compiler and the other one is a test compiler. Each goal is associated for Bund to a life cycle phase. For example, compare for Bund to a lifecycle phase. For example, compile is Bund to the compile phase, compile phase, and pass compile is Bund to the pass compile phase. As we mentioned earlier, when we do a build, this goes, will be one, when we bridge that phase, where the goal is associated to 1.2. And of course, this goal can be customized with additional configuration. For example, we can specify what Java version can be used for compile project. As we just saw earlier, it clips i.e. e.e. provides a few main and views like main and storm and test and so on. What if we want to run other main and views? For example, what if I want to do a main and true path? Now this is how we can do it. We select main and build. .. and here we can we can specify the face, the comp file face, in the field code goals. And then we can give this view that name, and we can quite make a main test compile for example. And save it and we can write and this will run main and compile build on this project and it will build a tool source files and build success. Later on we can, we want to rerun this build, we can go here and as we can see it saves MV and test point-how build here. So this is how we can run additional main-level in Eclipse. Now let's do another example and I want to use this example to show two more layout features, archetype and dependency management. Let's create another main project. And this time we'll leave this option create a simple project and check. In other words, this time we are going to create a project from a RK type. So what are RK types? We then RK types are basically project templates. I would like the ones provided by items. It's usually more convenient to create a project from a template than creating it from scratch. The good thing about maven archetypes is that anyone can create archetypes, so if your IDE doesn't provide a certain product template, you can create one for yourself. The downside is that because anyone can create artifacts, there are lots of low quality or no longer maintain archetypes all there. And that's what happens if you are on this screen and you select all catalogs, you'll see all the archetypes and it's impossible to find something that you you want here. It's just too much class. Most of those are are not that good to be famous. Now, mainland does provide some official architects like Quick Start and Labek you can. But those architects are very updated. So, not very good and because of these reasons I created my own archive for this class and is a guitar here. So the process of install is archetype is part of the process to second the demand on the I'm not going to show it here. And if you want, you can check out the video shown process of setting up the development environment. Anyway I already installed this archetypal micro computer and we can now use it to create web projects. So instead of selecting all catalogs, we will select default local and this bucket here, it's right here. And it's called simple server data archive. And we can use it to create web application. like before when gimita grew by the end and go through. web of creation. Like before, when GIMITA grew by E and I'm going to still use the CSCRI, searching for the time key, still in 31, and the artifact ID are quite new. Now for what the patients of the teleclass data classes must be in a package. They cannot be in the P-part package or a no package. Now, by default, maybe assumes that the top level package is the group ID plus the R-35 ID and I really don't like my top level package to be done long. So instead I'm just going to simply use CS8020 as a top level package. and also I'm going to uncheck one archetype generation interactively because if we're being... here as a pop-level package and also I'm going to uncheck one archetype generation interactively because if we leave this unchecked, we will ask us to enter package again or confirm package again. It's kind of unnecessary So, and check this and give it a top level package name, the rest reorder now and then we create the project. So now we have this MBL test tool project and in this project the archetype of automatically creates a server-led voice called a low-cell lid. It also creates HTML file, XHTML. But for more about service and web applications in a separate lecture here, I'm not going to actually run this. We saw how to create a web application using Earth type. And I want to show one more major feature, which is dependency management. A dependency of a project is basically a library's project depends on. In Maven, adding a dependency to a project is as simple as adding the core base of the library to content XML file. Mainly automatically downloads a library from an library repository and restore started locally for future use. For example, suppose in this project, suppose we want to do unit test using the library genuine. We can add it to the project like this. So, we go to conduct as well. Okay, so it already has a dependency here. And let's add one more, we'll say dependency and we'll say JUnit and it will show a bunch of JUnit for us to choose and we want additional we want this one I think the artifact ID is called cherry you will need not chain or dot bar or maybe depend on seeing a chain unit. Dependency, a chain-nones. So maybe it's not conjuring on it. Let's see. Let's try it either. The better suits, the better suits, the better suits, the better suits, the better suits, Let's start this one. D and D, and C. Okay, so I think it's this one. For some reason, this one doesn't show up in here, but unless you are going to see it, okay. All right. Now completely smoothly, but still better than manually done over the library, and add it to the product. So basically, as we can see here, if we want to add a library to the project, we just need to know the calling base of the library and then we add that to POM dot XML and later would automatically go to Unlight recorded three words and I agree, download it and add it to the project much better than we have to do it manually ourselves. It's really coming in. We actually does more than just grab the dependencies we specify. It also automatically has dependencies of a dependency, also known as transitive dependencies. And so in other words, if a library that we use depends on other libraries, those other libraries will be automatically included. Once again, it's very convenient. And sometimes we may have a situation where one library means a certain version of another library but a different version of the same library is needed by different dependency. This is known as dependency conflicts. It may then can down dependency conflicts in the opnet, please, based on certain rules, or manually, if we have some additional configuration for buying or it's very convenient to use Maven to handle libraries used by our projects. So to summarize, maybe it's a very important and very useful tool in the Java development. We don't have to be a name and expert to use it, but we do to understand a few basics since in particular the core needs, the group ID, the architecture and the stuff, the default directly structure is special. this one and what are the pure life cycles, pure life cycle faces and what it means when we say building store, or maybe store, or maybe compile and what is that mean in our archive, how to use it and how to add dependencies to our project. Those are basic things that we have to know as we'll use rewind, quite often the rest of the class. Okay, so this is it. Thank you and seeing the next review.